---
output: github_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Overview

netrankr is an R package that can be used for centrality analyses of networks.
Although it implements some indices, the main focus lies on an index-free assessment 
of centrality in networks. Most implemented methods are, however, more general and can be used 
whenever partial rankings have to be analysed.

## Install

```{r install, eval=FALSE}
require(devtools)
install_github("schochastics/netrankr")
```

## Details

Some features of the package are: 

* Working with the neighborhood inclusion preorder. This forms the bases 
  for any centrality analysis on undirected and unweighted graphs. 
  More details can be found in the dedicated vignette: 
  `vignette("neighborhood_inclusion",package="netrankr")`.
* Constructing graphs with a unique centrality ranking. 
  This class of graphs, known as threshold graphs, can be used to benchmark 
  centrality indices, since they only allow for one ranking of the nodes.
  For more details consult the vignette: `vignette("threshold_graph",package="netrankr")`.
* Probabilistic ranking methods. The package includes several function to 
  perform probabilistic rank analyses of nodes in a network. These include expected
  ranks and relative rank probabilities (how likely is it that a node is more central than another).
  An extensive example is given in the corresponding vignette (TODO).
}
 
To browse all vignettes use: `browseVignettes(package = "netrankr")`

## Notable functions

* `neighborhood_inclusion` and `positional_dominance` can be used to construct 
partial orders on a network.  While `neighborhood_inclusion` is very specific 
(undirected, unweighted networks), `positional_dominance` can be used with any 
kind of input network. If cost variables (e.g. distances) are used, set 
`benefit=FALSE`. If actor identities don't matter set `map=TRUE`. Consult the respective
vignettes for more detailed explanations.
* `threshold_graphs` constructs a random uniquely ranked graph. That is, a graph 
where all centrality indices yield the same ranking.
* `exact_rank_prob` performs a complete and exact rank analysis of a network, including 
expected ranks and relative rank probabilities (how likely is it that a node is 
more central than another?) as well as the number of possible centrality rankings.
For larger networks, various approximation functions can be used. See vignettes for help.

## Example

```{r ex, warning=FALSE,message=FALSE}
library(igraph)
library(netrankr)
set.seed(123)
g <- graph.empty(n=11,directed = FALSE)
g <- add_edges(g,c(1,11,2,4,3,5,3,11,4,8,5,9,5,11,6,7,6,8,
                    6,10,6,11,7,9,7,10,7,11,8,9,8,10,9,10))
# plot(g)
```

Calculate centrality scores with the `igraph` package.
```{r cent}
cent_scores <- data.frame(
   degree=degree(g),
   betweenness=round(betweenness(g),4),
   closeness=round(closeness(g),4),
   eigenvector=round(eigen_centrality(g)$vector,4),
   subgraph=round(subgraph_centrality(g),4))

apply(cent_scores,2,which.max)
```
Each index assigns the highest value to a different vertex! 

More generic approach via neighborhood-inclusion.
```{r ex_ni}
P <- neighborhood_inclusion(g)
P
D <- dominance_graph(P)
# plot(D)
```
If `P[u,v]=1` or equivalently `(u,v)` is an edge in `D`, then $N(u) \subseteq N[v]$
holds, which implies that $c(u) \leq c(v)$ for all centrality indices $c$!  

Neighborhood-inclusion defines a partial ranking on the set of nodes. Each ranking 
that is in accordance with this partial ranking defines a proper centrality ranking.
Each of these ranking can potentially be the outcome of a centrality index.  

The function `exact_rank_prob()` can be used to calculate all these ranking and produce
probabilistic centrality rankings.
```{r ex_p}
res <- exact_rank_prob(P)
str(res)
```
`lin.ext` is the number of possible rankings. For the graph `g` we could thus come up with
`r format(res$lin.ext,big.mark   = ",")` indices that would rank the node differently.  

`rank.prob` contains the probabilities for each node to occupy a certain rank. 
For instance, the probability for each node to be the most central one is as follows.
```{r most_central}
round(res$rank.prob[,11],2)
```

`relative.rank` contains the relative rank probabilites. An entry `relative.rank[u,v]`
indicates how likely it is that `v` is more central than `u`.
```{r rel_rank}
# How likely is it, that 6 is more central than 3?
round(res$relative.rank[3,6],2)
```

`expected.ranks` contains the expected centrality ranks for all nodes. They are 
derived on the basis of `rank.prob`.
```{r exp_rank}
round(res$expected.rank,2)
```
The higher the value, the more central a node is expected to be.

**Note**: The set of rankings grows exponentially in the number of nodes. The exact 
calculation thus becomes infeasible quite quickly. The package also implements a great variety
of approximation methods for larger networks. Check the manual for options.